---

# Some prerequisites

########################################
# Create data volumes for NginX
# Create NginX application container

# If the volume should be recreated, stop docker nginx container

- name: "Stop docker container {{ nginx_docker_container_name }}"
  docker_container:
    name: "{{ nginx_docker_container_name }}"
    image: "{{ nginx_docker_image }}"
    state: absent  # Remove container
    keep_volumes: false
  when: recreate_nginx_volumes == "always"

# (Re)Create the data volume
- name: Create volume for nginx data
  docker_volume:
    name: "{{ item }}"
    state: present
    driver: local
    recreate: "{{ recreate_nginx_volumes }}"
  loop: 
   - nginx_site_data_volume_name
   - nginx_config_volume_name
    
# Get the specified image for NginX
- name: get nginx docker image
  docker_image: 
    name: "{{ nginx_docker_image }}"
    tag: "{{ nginx_docker_image_tag }}"
    source: pull

# Create / start the container. Recreate is conditional
- name: create nginx docker container
  docker_container:
    name: "{{ nginx_docker_container_name }}"
    image: "{{ nginx_docker_image }}"
    state: started
    recreate: "{{ recreate_nginx_container }}"
    memory: "{{ nginx_max_memory }}"
    mounts: 
      - source: "{{ nginx_site_data_volume_name }}"
        target: "{{ nginx_site_data_volume_container_mount_point }}"
        type: volume
      - source: "{{ nginx_config_volume_name }}"
        target: "{{ nginx_config_volume_container_mount_point }}"
        type: volume
    hostname: "{{ nginx_docker_container_hostname }}"
    exposed_ports: "{{ nginx_docker_container_exposes_ports }}"
    published_ports: "{{ nginx_docker_container_publish_ports }}"
    user: "root" # should be changed
    restart_policy: always
  register: nginx_inspect_data

- name: Store IP of NginX server
  set_fact: 
    nginx_ip: "{{ nginx_inspect_data['ansible_facts']['docker_container']['NetworkSettings']['IPAddress'] }}"

- name: "Wait for NginX @ {{ nginx_ip }} : {{ nginx_docker_container_exposes_ports[0] }} to respond"
  wait_for:
    host: "{{ nginx_ip }}"
    port: "{{ nginx_docker_container_exposes_ports[0] }}"
    state: drained
    connect_timeout: 1
    timeout: 30
  register: nginx_responding
  until: nginx_responding is success
  retries: 10

##################################
#
##################################

# Get path to config volume for NginX container 
- name:
  docker_volume_info:
    name: "{{ nginx_config_volume_name }}"
  register: config_volume_data

# Add SSL certificate and key to /etc/nginx (configured in nginx_config_volume_container_mount_point)

- name:
  debug:
    msg: "{{ config_volume_data.volume.Mountpoint }}"


- name: Create directory ssl directory for NginX
  file:
    path: "{{ config_volume_patch }}/ssl"
    state: directory
    mode: u=rwx,g=,o=
  vars:
    config_volume_patch: "{{ config_volume_data.volume.Mountpoint }}"

- name: "Copy SSL certificate and private key to {{ nginx_config_volume_container_mount_point }}/ssl, volume path: {{ config_volume_data.volume.Mountpoint }}"
  copy:
    src: "{{ item }}"
    dest: "{{ config_volume_patch }}/ssl/{{ item | basename }}"
    owner: 
    group: 
    mode: u=rw,g=,o=
  vars:
    config_volume_patch: "{{ config_volume_data.volume.Mountpoint }}"
  loop:
    - "{{ certs_dir }}/{{ internal_certs_cert_file }}"
    - "{{ certs_stuff_location }}/{{ current_inventory_env }}-int-cert-key-priv.pem"

# Get the specified image for OpenLDAP
#- name: get phpldapadmin docker image
#  docker_image: 
#    name: "{{ openldap_admin_docker_image }}"
#    tag: "{{ openldap_admin_docker_image_tag }}"
#    source: pull


#- name: Create OpenLDAP entries
#  block:
#  - name: "Create OpenLDAP {{ openldap_postgres_dbuser }} account"
#    ldap_entry:
#      state: present
#      server_uri: "{{ openldap_ip }}"
#      dn: ou=users,dc=nnworks,dc=com
#      objectClass: organizationalUnit
#
#  when: openldap_responding is success